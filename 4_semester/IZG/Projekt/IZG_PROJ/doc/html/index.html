<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Izg project: Izg project.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Izg project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Izg project. </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#zadani">Zadání projektu do předmětu IZG.</a></li>
<li class="level1"><a href="#rozdeleni">Rozdělení</a></li>
<li class="level1"><a href="#teorie">Teorie</a><ul><li class="level2"><a href="#terminologie">Terminologie</a></li>
</ul>
</li>
<li class="level1"><a href="#sestaveni">Sestavení</a></li>
<li class="level1"><a href="#spousteni">Spouštění</a></li>
<li class="level1"><a href="#ovladani">Ovládání</a></li>
<li class="level1"><a href="#odevzdavani">Odevzdávání</a></li>
<li class="level1"><a href="#hodnoceni">Hodnocení</a></li>
<li class="level1"><a href="#soutez">Soutěž</a></li>
<li class="level1"><a href="#zaver">Závěrem</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="zadani"></a>
Zadání projektu do předmětu IZG.</h1>
<div class="image">
<img src="bunny.png" alt="bunny.png"/>
<div class="caption">
Výstup projektu</div></div>
<p> Vašim úkolem je naimplementovat softwarový vykreslovací řetězec (pipeline). Pomocí vykreslovacího řetězce vizualizovat model králička s phongovým osvělovacím modelem a phongovým stínováním. V tomto projektu nebudeme pracovat s <a class="el" href="structGPU.html" title="This struct represents GPU data. ">GPU</a>, ale budeme se snažit simulovat její práci. Cílem je pochopit jak vykreslovací řetěc funguje, z čeho je složený a jaká data se v něm pohybují.</p>
<p>Váš úkol je složen ze tří částí: naprogramovat vykreslovací řetězec, naprogramovat vykreslování králička pomocí cpu_* příkazů a napsat shadery pro phongův osvětlovací model. Musíte doplnit implementace několika funkcí a rozchodit kreslení modelu králička. Funkce mají pevně daný interface (Vstupy a výstupy). Seznam všech úkolů naleznete zde <a class="el" href="todo.html">todo.html</a>. Úkoly týkající se pouze <a class="el" href="structGPU.html" title="This struct represents GPU data. ">GPU</a> strany naleznete zde <a class="el" href="group__gpu__side.html">GPU</a>. Úkoly týkající se pouze CPU strany naleznete zde <a class="el" href="group__cpu__side.html">CPU</a>. Úkoly týkající se pouze shaderů naleznete zde <a class="el" href="group__shader__side.html">Shadery</a>.</p>
<p>Každý úkol má přiřazen akceptační test, takže si můžete snadno ověřit funkčnosti vaší implementace.</p>
<p>V projektu jsou přítomny i nějaké další příklady. Tyto příklady můžete využít pro inspiraci a návod jak napsat cpu stranu a shadery.</p>
<p>Pro implementaci gpu teorii na této stránce, doxygen dokumentaci, video návodu a látce probírané na přednáškách.</p>
<p><a href="https://www.youtube.com/watch?v=Y2jPx8d20fE">Video Návod</a>.</p>
<h1><a class="anchor" id="rozdeleni"></a>
Rozdělení</h1>
<p>Projekt je rozdělen do několika podsložek:</p>
<p><b>student/</b> Tato složka obsahuje soubory, které využijete při implementaci projektu. Složka obsahuje soubory, které budete odevzávat a podpůrné knihovny. Všechny soubory v této složce jsou napsány v jazyce C abyste se mohli podívat jak jednotlivé části fungují.</p>
<p><b>tests/</b> Tato složka obsahuje akceptační a performanční testy projektu. Akceptační testy jsou napsány s využitím knihovny catch. Testy jsou rozděleny do testovacích případů (TEST_CASE). Daný TEST_CASE testuje jednu podčást projektu.</p>
<p><b>queue/</b> Tato složka obsahuje implementaci fronty. <b>vector/</b> Tato složka obsahuje implementaci vectoru (c++) <b>stack/</b> Tato složka obsahuje implementaci zásobníku. <b>errorCodes/</b> Tato složka obsahuje chybové kódy.</p>
<p><b>doc/</b> Tato složka obsahuje doxygen dokumentaci projektu. Můžete ji přegenerovat pomocí příkazu doxygen spuštěného v root adresáři projektu.</p>
<p><b>3rdParty/</b> Tato složka obsahuje hlavičkový soubor pro unit testy - catch.hpp. Z pohledu projektu je nezajímavá. Catch je knihovna složená pouze z hlavičkového souboru napsaného v jazyce C++. Poskytuje několik užitečných maker pro svoji obsluhu. TEST_CASE - testovací případ (například pro testování jedné funkce). WHEN - toto makro popisuje způsob použití (například volání funkce s parametery nastavenými na krajní hodnoty). REQUIRE - toto makro vyhodnotí podmínku a případně vypíše chybu (například chcete ověřit, že vaše funkce vrátila správnou hodnotu).</p>
<p><b>images/</b> Tato složka obsahuje doprovodné obrázky pro dokumentaci v doxygenu. Z pohledu projektu je nezajímavá.</p>
<p>Složka student/ obsahuje soubory, které se vás přímo týkají:</p>
<p><b>drawTriangles.c</b> obsahuje funkci pro vykreslování trojúhelníků - tu máte naprogramovat editovat.</p>
<p><b>phongMethod.c</b> obsahuje cpu stranu a shadery pro vykresleni králička - toto máte naprogramovat. editovat.</p>
<p>Funkce s předponou cpu_ můžou být volány pouze na straně, v souboru phongMethod.c. Funkce s předponou gpu_ můžou být volány pouze na straně <a class="el" href="structGPU.html" title="This struct represents GPU data. ">GPU</a>, v souboru drawTriangles.c. Funkce bez předpony můžou být volány na CPU, <a class="el" href="structGPU.html" title="This struct represents GPU data. ">GPU</a> tak v rámci shaderu.</p>
<p>Struktury, které se vyskytují pouze na <a class="el" href="structGPU.html" title="This struct represents GPU data. ">GPU</a> straně jsou uvozeny prefixem <a class="el" href="structGPU.html" title="This struct represents GPU data. ">GPU</a>. Struktury bez předpony lze využít jak na CPU tak <a class="el" href="structGPU.html" title="This struct represents GPU data. ">GPU</a> straně či v shaderu.</p>
<p>Projekt je postaven nad filozofií OpenGL. Spousta funkcí má podobné jméno.</p>
<h1><a class="anchor" id="teorie"></a>
Teorie</h1>
<p>Typické grafické API (OpenGL/Vulkan/DirectX) je složeno ze 2 částí: CPU a <a class="el" href="structGPU.html" title="This struct represents GPU data. ">GPU</a> strany.</p>
<p>CPU strana se obvykle stará o tyto úkoly:</p><ul>
<li>Příprava dat pro kreslení (modely, textury, matice, ...)</li>
<li>Upload dat na <a class="el" href="structGPU.html" title="This struct represents GPU data. ">GPU</a> a nastavení <a class="el" href="structGPU.html" title="This struct represents GPU data. ">GPU</a></li>
<li>Spuštění vykreslení</li>
</ul>
<p><a class="el" href="structGPU.html" title="This struct represents GPU data. ">GPU</a> strana je složena ze dvou částí: video paměti a zobrazovacího řetězce. Vykreslovací řetězec se skládá z několika částí:</p><ul>
<li>Vertex Puller (načtení dat z bufferů a výpočet gl_VertexID)</li>
<li>Vertex Processor (vyvolávání vertex shaderu)</li>
<li><a class="el" href="structPrimitive.html" title="This struct represents primitive. ">Primitive</a> Assembly (sestavení primitiva/trojúhelníku)</li>
<li>Clipping (nebudete muset implementovat)</li>
<li>Perspektivní dělení</li>
<li>View-port transformace</li>
<li>Rasterize (středy pixelů musí ležet uvnitř trojúhelníku, perspektivně korektní interpolace atributů)</li>
<li>Fragment Processor (vyvolávání fragment shaderu)</li>
<li>Per-Fragment Operations (depth test) <br />
</li>
</ul>
<p><b>Vertex Puller</b> Vertex puller je složen z N čtecích hlav, které sestavují vrchol. Jeho úkolem je spočítat číslo vrcholů gl_VertexID. Číslo vrcholu je dáno pořadovým číslem vyvolání (invokací) vertex shaderu - to v případě že není použito indexování. Jinak je číslo dáno indexem v indexačnímu bufferu. Indexační buffer může mít růzou velikost indexu - 8bit, 16bit a 32bit. Pokud je zapnuto indexování, pak je číslo vrcholu dáno položnou v indexačním bufferu, kde položka (index) v bufferu je vybráno na základě čísla invokace vertex shaderu. Dalším úkolem vertex pulleru je připravit aributy vrcholu, který vstupuje do vertex shaderu. <a class="el" href="structGPUInVertex.html" title="This struct represents input vertex of vertex shader. ">GPUInVertex</a> je složen z M atributů, každý odpovídá jedné čtecí hlavě z vertex pulleru. Čtecí hlava <a class="el" href="structGPUVertexPullerHead.html" title="This struct represents one vertex puller head. ">GPUVertexPullerHead</a> obsahuje nastavení - offset, stride, size a buffer id. Pokud je čtecí hlava povolena, měla by zkopírovat data (o velikosti size) z bufferu od daného offsetu, s krokem stride. Všechny velikosti jsou v bajtech. Krok se použije při čtení různých vrcholů: atributy by měly být čteny z adresy: buf_ptr + offset + stride*gl_VertexID <br />
 <b>Vertex Processor</b> Vertex processor vyvolává vertex shader. Vertex shader by měl obržet správna data ve struktuře <a class="el" href="structGPUVertexShaderData.html" title="Vertex shader data. ">GPUVertexShaderData</a>, která je složena ze vstupního vrcholu, výstupního vrcholu a uniformních proměnných <a class="el" href="structGPUUniforms.html" title="All uniforms. ">GPUUniforms</a>. Uniformní proměnné jsou přiřazeny ke každému programu zvlášť a jsou uloženy ve struktuře <a class="el" href="structGPUProgram.html" title="This structure represents shader program. ">GPUProgram</a>. Uniformní proměnné zůstávání konstantní v průběhu vykresovácího příkazu. Vertex shader by měl zapisovat do výstupního vrcholu <a class="el" href="structGPUOutVertex.html" title="This struct represents output vertex of vertex shader. ">GPUOutVertex</a> - do atributů a do proměnné gl_Position. <br />
 <b><a class="el" href="structPrimitive.html" title="This struct represents primitive. ">Primitive</a> Assembly</b> Sestavení primitiv by mělo dát dohromady primitiva (trojúhelníky) z N posobě jdoucích vrcholů. <br />
 <b>Perspektivní dělení</b> Perspektivní dělení následuje za clippingem/cullingem (není součást projektu) a provádí převod z homogenních souřadnic na kartézské pomocí dělení w. <br />
 <b>View-port transformace</b> View-port transformace převádí xy rozsah z intervalu &lt;-1,+1&gt; na rozsah &lt;0,velikost framebufferu). <br />
 <b>Rasterizace</b> Rasterizace rasterizuje transformovaný trojúhelník. Rasterizace produkuje fragmenty v případě, že <b>střed</b> pixelu leží uvnitř trojúhelníka. Rasterizace by měla zapsat souřadnice fragmentu do proměnné gl_FragCoord. Pozice fragmentu obsahuje v x,y souřadnici na obrazovce a v z hloubku. Další úkol rasterizace je interpolace vertex attributů do fragment attributů. Atributy které jsou posílány z vertex shaderu do fragment shaderu jsou poznačeny v proměnné vs2fsType ve struktuře <a class="el" href="structGPUProgram.html" title="This structure represents shader program. ">GPUProgram</a>. Úkolem rasterizéru je perspektivně korektně interpolovat atributy. Perspektivně korektní interpolace využívá pro interpolaci barycentrické koordináty spočítané z 3D trojúhelníku a ne z 2D trojúhelníku. Interpolaci je možné provést pomocí: (att0*l0/h0 + att1*l1/h1 + att2*l2/h2) / (l0/h0 + l1/h1 + l2/h2). Kde l0,l1,l2 jsou barycentrické koordináty ve 2D, h0,h1,h2 je homogenní složka vrcholů a att0,att1, att2 je atribut vrcholu. <br />
 <b>Fragment processor</b> Fragment processor spouští fragment shader nad každým fragmentem. Data pro fragment shader jsou uložena ve struktuře <a class="el" href="structGPUFragmentShaderData.html" title="Fragment shader data. ">GPUFragmentShaderData</a>. Struktura je složena ze tří položek: <a class="el" href="structGPUUniforms.html" title="All uniforms. ">GPUUniforms</a>, <a class="el" href="structGPUInFragment.html" title="This struct represents input fragment. ">GPUInFragment</a> a <a class="el" href="structGPUOutFragment.html" title="This struct represents output fragment. ">GPUOutFragment</a>. Fragment processor by měl správně vyplnit struktury <a class="el" href="structGPUInFragment.html" title="This struct represents input fragment. ">GPUInFragment</a> a <a class="el" href="structGPUUniforms.html" title="All uniforms. ">GPUUniforms</a> z výsledků rasterizace. <br />
 <b>Per-fragment operace</b> Per-fragment operace provádí depth test. Ověření zda je nový fragment blíže než hloubka poznačená ve framebufferu. Pokud je hloubka nového fragment menší, barva a hloubka fragmentu je zapsána do framebufferu. Dejte pozor na přetečení rozsahu gl_FragColor. Před zápisem je nutné ořezat barvu do rozsahu &lt;0,1&gt;. <br />
</p>
<h2><a class="anchor" id="terminologie"></a>
Terminologie</h2>
<p><b>Vertex</b> je kolekce několika vertex atributů. Tyto atributy mají svůj typ a počet komponent. Každý vertex atribut má nějaký význam (pozice, hmotnost, texturovací koordináty), které mu přiřadí programátor/modelátor. Z několika vrcholů je složeno primitivum (trojúhelník, úsečka, ...)</p>
<p><b>Vertex atribut</b> je jedna vlastnost vrcholu (pozice, normála, texturovací koordináty, hmotnost, ...). Atribut je složen z 1,2,3 nebo 4 komponent daného typu (FLOAT, INT, ...). Sémantika atributu není pevně stanovena (atributy mají pouze pořadové číslo - attribIndex) a je na každém programátorovi/modelátorovi, jakou sémantiku atributu přidělí. </p><div class="image">
<object type="image/svg+xml" data="primitive.svg">primitive.svg</object>
<div class="caption">
Vertex attributes</div></div>
<p> <b>Fragment</b> je kolekce několika atributů (podobně jako Vertex). Tyto atributy mají svůj typ a počet komponent. Fragmenty jsou produkovány resterizací, kde jsou atributy fragmetů vypočítány z vertex atributů pomocí interpolace. Fragment si lze představit jako útržek původního primitiva.</p>
<p><b>Fragment atribut</b> je jedna vlastnost fragmentu (podobně jako vertex atribut).</p>
<p><b>Interpolace</b> Při přechodu mezi vertex atributem a fragment atributem dochází k interpolaci atributů. Atributy jsou váhovány podle pozice fragmentu v trojúhelníku (barycentrické koordináty). </p><div class="image">
<object type="image/svg+xml" data="interpolation.svg">interpolation.svg</object>
<div class="caption">
Vertex attribute interpolation</div></div>
<p> <b>Vertex Processor</b> (často označován za Vertex Shader) je funkční blok, který je vykonáván nad každým vertexem. Jeho vstup i výstup je Vertex. Výstupní vertex má obvykle jiné vertex atributy než vstupní vertex. Výstupní vertex má vždy atribut - gl_Position (pozice vertexu v clip-space). Vstupní vertex má vždy atribut - gl_VertexID (číslo vrcholu, s ohledem na indexování). Vertex Processor se obvykle stará o transformace vrcholů modelu (posuny, rotace, projekce). Jelikož Vertex Processor pracuje po vrcholech, je vhodný pro efekty jako vlnění na vodní hladině, displacement mapping apod. Vertex Processor má informace pouze o jednom vrcholu v daném čase (neví nic o sousednostech vrcholů). Vertex processor je programovatelný.</p>
<p><b>Fragment Processor</b> (často označován za Fragment Shader/Pixel Shader) je funkční blok, který je vykonáván nad každým fragmentem. Jeho vstup i výstup je Fragment. Výstupní fragment má obykle jiné attributy. Fragment processor je programovatelný.</p>
<p><b>Shader</b> je program/funkce, který běží na některé z programovatelných částí zobrazovacího řetezce. Shader má vstupy a výstupy, které se mění s každou jeho invokací. Shader má také vstupy, které zůstávají konstantní a nejsou závislé na číslu invokace shaderu. Shaderů je několik typů, v tomto projektu se používají pouze 2 - vertex shader a fragment shader. V tomto projektu jsou shadery reprezentovány pomocí standardních Cčkovských funkcí.</p>
<p><b>Vertex Shader</b> je program, který běží na vertex processoru. Jeho vstupní interface obsahuje: vertex, uniformní proměnné a další proměnné (číslo vrcholu gl_VertexID, ...). Jeho výstupní inteface je vertex, který vždy obsahuje proměnnou gl_Position - pozici vertexu v clip-space.</p>
<p><b>Fragment Shader</b> je program, který běží na fragment processoru. Jeho vstupní interface obsahuje: fragment, uniformní proměnné a proměnné (souřadnici fragmentu ve screen-space gl_FragCoord, ...). gl_FragCoord.xy - souřadnice ve screen space gl_FragCoord.z - hloubka Jeho výstupní interface je fragment. V projektu obsahuje atribut gl_FragColor - pro výstupní barvu.</p>
<p><b>Shader Program</b> je kolekce programů, které běží na programovatelných částech zobrazovacího řetězce. Obsahuje vždy maximálně jeden shader daného typu. V tompto projektu je program reprezentován pomocí dvou ukazatelů na funkce. </p><div class="image">
<object type="image/svg+xml" data="shader_program.svg">shader_program.svg</object>
<div class="caption">
This shader program is composed of vertex shader and fragment shader</div></div>
<p> <b>Buffer</b> je lineární pole dat ve video paměti na <a class="el" href="structGPU.html" title="This struct represents GPU data. ">GPU</a>. Do bufferů se ukládají vertex attributy vextexů modelů nebo indexy na vrcholy pro indexované vykreslování.</p>
<p><b>Uniformní proměnná</b> je proměná uložená v konstantní paměti <a class="el" href="structGPU.html" title="This struct represents GPU data. ">GPU</a>. Všechny programovatelné bloky zobrazovacího řetězce z nich mohou pouze číst. Jejich hodnota zůstává stejná v průběhu kreslení (nemění se v závislosti na číslu vertexu nebo fragmentu). Jejich hodnodu lze změnit z CPU strany pomocí funkcí jako je uniform1f, uniform1i, uniform2f, uniformMatrix4fv apod. Uniformní proměnné jsou vhodné například pro uložení transformačních matic nebo uložení času.</p>
<p><b>Vertex Puller</b> se stará o přípravů vrcholů. K tomuto účelu má tabulku s nastavením. Vertex puller si můžete představit jako sadu čtecích hlav. Každá čtecí hlava se stará o přípravu jednoho vertex atributu. Mezi nastavení čtecí hlavy patří: ukazatel na začátek bufferu, offset a krok. Vertex puller může obsahovat indexování.</p>
<p><b>Zobrazovací řetězec</b> je obvykle kus hardware na grafické kartě, který se stará o vyreslování. Grafická karta je složena ze dvou částí: paměti a zobrazovacího řetězce. V paměti se nacházejí buffery, textury, uniformní proměnné, programy, nastavení vertex pulleru a framebuffery. Pokud se spustí kreslení N vrcholů, je vertex puller spuštěn N krát a sestaví N vrcholů. Nad každým vrcholem je puštěn vertex shader. Výstupem vertex shaderu je nový vrchol. Blok sestavení primitiv "si počká" na 3 vrcholy z vertex shaderu (pro trojúhelník) a vloží je do jedné struktury. Blok clipping ořeže trojúhelníky pohledovým jehlanem. Následuje perspektivní dělení, které vydělí pozice vertexů homogenní složkou. Poté následuje viewport transformace, která podělené vrcholy transformuje do rozlišení obrazovky. Rasterizace trojúhelníky nařeže na fragmenty a interpoluje vertex atributy. Nad každým fragmentem je spuštěn fragment shader. Než jsou fragmenty zapsány zpět do paměti <a class="el" href="structGPU.html" title="This struct represents GPU data. ">GPU</a> (framebufferu) jsou provedeny per-fragment operace (zjištění viditelnosti fragmentů podle hloubky uchované v depth bufferu). </p><div class="image">
<object type="image/svg+xml" data="rendering_pipeline.svg">rendering_pipeline.svg</object>
<div class="caption">
Simplified rendering pipeline</div></div>
<p> <b>ObjectID</b> je číslo odkazující se na jeden konkrétní objekt na <a class="el" href="structGPU.html" title="This struct represents GPU data. ">GPU</a>. Každy buffer, program, vertex puller má přiřazeno/rezervováno takové číslo (BufferID, ProgramID, VertexPullerID).</p>
<p><b>Uniformní lokace</b> je číslo, které reprezentuje jednu uniformní proměnnou.</p>
<p><b>VertexShaderInvocation</b> je pořadové číslo vyvolání vertex shaderu.</p>
<p><b>gl_VertexID</b> je číslo vrcholu, které je vypočítáno pomocí indexování a pořadového čísla vyvolání vertex shaderu.</p>
<p><b>Indexované kreslení</b> je způsob snížení redundance dat s využitím indexů na vrcholy. </p><div class="image">
<object type="image/svg+xml" data="drawElements.svg">drawElements.svg</object>
<div class="caption">
Difference between indexed and non-indexed drawing</div></div>
 <h1><a class="anchor" id="sestaveni"></a>
Sestavení</h1>
<p>Projekt byl testován na Ubuntu 18.04, Visual Studio 2015. Projekt vyžaduje 64 bitové sestavení. Projekt využívá build systém <a href="https://cmake.org/">CMAKE</a>. CMake je program, který na základně konfiguračních souborů "CMakeLists.txt" vytvoří "makefile" v daném vývojovém prostředí. Dokáže generovat makefile pro Linux, mingw, solution file pro Microsoft Visual Studio, a další. Postup:</p><ol type="1">
<li>Zkompilovat a nainstalovat SDL2 pomocí CMAKE - toto vyprodukuje adresářovou strukturu installSložkaSDL2/ V té strutkuře jsou knihovny (*.dll, *.lib, *.so, *.a), inkludy (*.h) a cmake skripty (*.cmake).</li>
<li>stáhnout projekt</li>
<li>rozbalit projekt</li>
<li>ve složce build spusťte "cmake-gui .." případně "ccmake .."</li>
<li>vyberte si překladovou platformu (64 bit).</li>
<li>configure</li>
<li>nastavte do proměnné SDL2_DIR cestu k SDLConfig.cmake souboru (obvykle: installSložkaSDL2/lib/cmake/SDL2/</li>
<li>generate</li>
<li>make nebo otevřete vygenerovnou Microsoft Visual Studio Solution soubor.</li>
<li>pokud vám projekt nejde spustit (chybí SDL2.dll) překupírujte dané DLL k exači projetku.</li>
</ol>
<p>Projekt vyžaduje pro sestavení knihovnu <a href="https://www.libsdl.org/download-2.0.php">SDL2</a>. <b>Musíte</b> si knihovnu stáhnou, zkompilovat a nainstalovat pomocí CMAKE. Projekt využívat targety SDL2::SDL2 a SDL2::SDL2main, které jsou uvedeny v cmake configurácích pokud je knihovna správně zkompilována a nainstalována.</p>
<h1><a class="anchor" id="spousteni"></a>
Spouštění</h1>
<p>Projekt je možné po úspěšném přeložení pustit přes aplikaci <b>izgProject</b>. Projekt akceptuje několik argumentů příkazové řádky:</p><ul>
<li><b>-c ../tests/output.bmp</b> spustí akceptační testy, soubor odkazuje na obrázek s očekávaným výstupem.</li>
<li><b>-p</b> spustí performanční test.</li>
</ul>
<h1><a class="anchor" id="ovladani"></a>
Ovládání</h1>
<p>Program se ovládá pomocí myši a klávesnice:</p><ul>
<li>stisknuté levé tlačítko myši + pohyb myší - rotace kamery</li>
<li>stisknuté pravé tlačítko myši + pohyb myší - přiblížení kamery</li>
<li>"n" - přepne na další scénu/metodu "p" - přepne na předcházející scénu/metodu</li>
</ul>
<h1><a class="anchor" id="odevzdavani"></a>
Odevzdávání</h1>
<p>Před odevzdáváním si zkontrolujte, že váš projekt lze přeložit na merlinovi. Zkopirujte projekt na merlin a spusťte skript: <b>./merlinCompilationTest.sh</b>. Odevzdávejte pouze soubory drawTriangles.c a phongMethod.c. Soubory zabalte do archivu proj.zip. Po rozbalení archivu se <b>NESMÍ</b> vytvořit žádná složka. Příkazy pro ověření na Linuxu: zip proj.zip student_pipeline.c student_cpu.c student_shader.c, unzip proj.zip. Studenti pracují na řešení projektu samostatně a každý odevzdá své vlastní řešení. Poraďte si, ale řešení vypracujte samostatně!</p>
<h1><a class="anchor" id="hodnoceni"></a>
Hodnocení</h1>
<p>Množství bodů, které dostanete, je odvozeno od množství splněných akceptačních testů a podle toho, zda vám to kreslí správně (s jistou tolerancí kvůli nepřesnosti floatové aritmetiky). Automatické opravování má k dispozici větší množství akceptačních testů (kdyby někoho napadlo je obejít). Pokud vám aplikace spadne v rámci testů, dostanete 0 bodů. Pokud aplikace nepůjde přeložit, dostanete 0 bodů.</p>
<h1><a class="anchor" id="soutez"></a>
Soutěž</h1>
<p>Pokud váš projekt obdrží plný počet bodů, bude zařazen do soutěže o nejrychlejší implementaci zobrazovacího řetězce. Můžete přeimplementovat cokoliv v odevzdávaných souborech pokud to projde akceptačními testy a kompilací.</p>
<h1><a class="anchor" id="zaver"></a>
Závěrem</h1>
<p>Ať se dílo daří a ať vás grafika alespoň trochu baví! V případě potřeby se nebojte zeptat (na fóru nebo napište přímo vedoucímu projektu <a href="#" onclick="location.href='mai'+'lto:'+'imi'+'le'+'t@f'+'it'+'.vu'+'tb'+'r.c'+'z'; return false;">imile<span style="display: none;">.nosp@m.</span>t@fi<span style="display: none;">.nosp@m.</span>t.vut<span style="display: none;">.nosp@m.</span>br.c<span style="display: none;">.nosp@m.</span>z</a>). </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 26 2019 23:01:24 for Izg project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
