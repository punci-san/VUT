#include <stdio.h>          /* printf()                 */
#include <stdlib.h>         /* exit()                   */
#include <unistd.h>
#include <sys/types.h>      /* key_t, sem_t, pid_t      */
#include <sys/wait.h>       /* usleep,                  */
#include <sys/time.h>       /*  struct timeval          */
#include <sys/shm.h>        /* shmat(), IPC_RMID        */
#include <errno.h>          /* errno, ECHILD            */
#include <semaphore.h>      /* sem_open(), sem_destroy(), sem_wait().. */
#include <fcntl.h>          /* O_CREAT, O_EXEC          */
#include <ctype.h>          /* isdigit                  */

// constant strings
#define ARRIVAL_NAME "arrival"
#define BOARDING_NAME "boarding"
#define RIDE_NAME "ride"
#define OK_NAME "ok"
#define PRINTING_NAME "printing"
#define FILE_NAME "proj2.out"
#define MILI_TO_MICRO 1000

// public variables
// will hold keys generated by ftok
key_t a_key;
key_t active_riders_key;
key_t waiting_riders_key;

// will hold shared memory value
int shm_a;
int shm_active_riders;
int shm_waiting_riders;

// shared variable
int *a = NULL;
int *active_riders = NULL;
int *waiting_riders = NULL;

// shared semaphores
sem_t *arrival = NULL;
sem_t *boarding = NULL;
sem_t *ride = NULL;
sem_t *ok = NULL;
sem_t *printing = NULL;

// contains PID of child process for main
// contains 0 for child process
pid_t bus;
pid_t rider_creator;

// file
FILE *fp;

// function declaration
int random_max(int max);
void clean_up();
int isNumber(char number[]);

// will generate random number between 0 and max
int random_max(int max)
{
  // Save time
  struct timeval t1;
  // get time of day
  gettimeofday(&t1,NULL);
  // generate seed for rand function
  srand(t1.tv_usec * t1.tv_sec);
  // minimum = 0 max will be given
  int min = 0;
  // calculate random using rand() functon with floating point numbers for more randomness
  int result = min + (max-min) * (double)rand() / (double)RAND_MAX + 0.5;
  // return result;
  return result;
}

// will clean everything if program finished succesfully or not
void clean_up()
{
  // detach memory segments
  shmdt(a);
  shmdt(active_riders);
  shmdt(waiting_riders);
  // remove shared memory identifier from the system and destroy memory segment
  shmctl(shm_a,IPC_RMID,NULL);				// IPC_RMID does not need buffer so we can use NULL
  shmctl(shm_active_riders,IPC_RMID,NULL);
  shmctl(shm_waiting_riders,IPC_RMID,NULL);

  // close semaphores
  sem_close(arrival);
  sem_close(boarding);
  sem_close(ride);
  sem_close(ok);
  sem_close(printing);

  // close file
  fclose(fp);
}

// test if argument is number
int isNumber(char number[])
{
  // loop until we loop through all
  for (int i = 0; number[i] != 0; i++)
  {
    // check if is number
    if (!isdigit(number[i]))
    {
      // not number return error
      return 0;
    }
  }
  // is number
  return 1;
}

int main(int argc, char **argv)
{
  // check if the arguments are correctly given
	if (argc == 5)
	{
    // is argument 1 number ?
    if (!isNumber(argv[1]))
    {
      fprintf(stderr,"Wrong first argument.\n");
      exit(EXIT_FAILURE);
    }
    // is argument 2 number ?
    if (!isNumber(argv[2]))
    {
      fprintf(stderr,"Wrong second argument.\n");
      exit(EXIT_FAILURE);
    }
    // is argument 3 number ?
    if (!isNumber(argv[3]))
    {
      fprintf(stderr,"Wrong third argument.\n");
      exit(EXIT_FAILURE);
    }
    // is argument 4 number ?
    if (!isNumber(argv[4]))
    {
      fprintf(stderr,"Wrong fourth argument.\n");
      exit(EXIT_FAILURE);
    }
    // check first argument if is higher than 0 ; contains number of rider processes to generate
		if (atoi(argv[1]) <= 0)
		{
			fprintf(stderr,"First argument out of range.\n");
			exit(EXIT_FAILURE);
		}
    // check second argument if is higher than 0  ; contains bus capacity
		if (atoi(argv[2]) <= 0)
		{
			fprintf(stderr,"Second argument out of range.\n");
			exit(EXIT_FAILURE);
		}
    // check third argument if is in range <0,1000> ; contains spawn max time of riders
		if (atoi(argv[3]) > 1000|| atoi(argv[3]) < 0)
		{
			fprintf(stderr,"Third argument out of range.\n");
			exit(EXIT_FAILURE);
		}
    // check fourth argument if is in range <0,1000> ; contains ride max time of bus
		if (atoi(argv[4]) > 1000|| atoi(argv[4]) < 0)
		{
			fprintf(stderr,"Fourth argument out of range.\n");
			exit(EXIT_FAILURE);
		}
	}
	else
	{
		fprintf(stderr,"Not enough arguments.\n");
		exit(EXIT_FAILURE);
	}

  // variables that will hold user input
	int riders_create = atoi(argv[1]);
	int bus_capacity = atoi(argv[2]);
	int bus_ride_time = atoi(argv[3]);
	int rider_spawn_time = atoi(argv[4]);

  // open file
  fp = fopen(FILE_NAME,"w");

  // so the file buffer will be filled according to *a
  setbuf(fp, NULL);

  // opening semaphore arrival for controling entering of riders
	arrival = sem_open(ARRIVAL_NAME,O_CREAT | O_EXCL,0666,riders_create); // initialize semaphore wil open value so if some riders start sooner than bus
	if (arrival == SEM_FAILED) // semapore failed to open                    they can enter the station
	{
    clean_up();
    perror("Semaphore arrival failed ");
		exit(EXIT_FAILURE);
	}
	sem_unlink(ARRIVAL_NAME);

  // opening semaphore boarding for controling when can riders board
	boarding = sem_open(BOARDING_NAME,O_CREAT | O_EXCL,0666,0); // initialize locked semaphore
	if (boarding == SEM_FAILED) // semapore failed to open
	{
    clean_up();
    perror("Semaphore boarding failed ");
		exit(EXIT_FAILURE);
	}
	sem_unlink(BOARDING_NAME);

  // opening semaphore ride for controling when can riders finish
	ride = sem_open(RIDE_NAME,O_CREAT | O_EXCL,0666,0);
	if (ride == SEM_FAILED)
	{
    clean_up();
    perror("Semaphore ride failed ");
		exit(EXIT_FAILURE);
	}
	sem_unlink(RIDE_NAME);

  // opening semaphore ok for controling bus based on rider actions
	ok = sem_open(OK_NAME,O_CREAT | O_EXCL,0666,0);
	if (ok == SEM_FAILED)
	{
    clean_up();
    perror("Semaphore ok failed ");
		exit(EXIT_FAILURE);
	}
	sem_unlink(OK_NAME);

  // controls printing into file so no 2 processes can print at the same time
  printing = sem_open(PRINTING_NAME, O_CREAT | O_EXCL,0666,1);  // initialize open
  if (printing == SEM_FAILED)
  {
    clean_up();
    perror("Semaphore printing failed ");
    exit(EXIT_FAILURE);
  }
  sem_unlink(PRINTING_NAME);

  // create shared *a variable that will be incrementing
	a_key = ftok("/tmp",'a');		// convert path to key_t
	if (a_key ==  (key_t)-1)
	{
    clean_up();
		perror("Ftok failed ");
		exit(EXIT_FAILURE);
	}
	shm_a = shmget(a_key,sizeof(int),0666 | IPC_CREAT); // use the key_t to find the shared memory segment
	if (shm_a < 0)
	{
    clean_up();
		perror("Shmget failed ");
		exit(EXIT_FAILURE);
	}
	a = (int *)shmat(shm_a,NULL,0);  // attach memory into pointer
	*a = 1;          // numbers begin from 1


	active_riders_key = ftok("/tmp",'b');		// convert path to key_t
	if (active_riders_key == (key_t)-1)
	{
    clean_up();
		perror("Ftok failed ");
		exit(EXIT_FAILURE);
	}
	shm_active_riders = shmget(active_riders_key,sizeof(int),0666 | IPC_CREAT); // use the key_t to find the shared memory segment
	if (shm_active_riders < 0)
	{
    clean_up();
		perror("Shmget failed ");
		exit(1);
	}
	active_riders = (int *)shmat(shm_active_riders,NULL,0);	// attach shared memory segment
	*active_riders = riders_create;	// set shared memory to equal number of riders

  // create shared variable that will keep number of riders waiting for bus
  waiting_riders_key = ftok("/tmp",'c');
  if (waiting_riders_key == (key_t)-1)
  {
    clean_up();
    perror("Ftok failed ");
    exit(1);
  }
  shm_waiting_riders = shmget(waiting_riders_key,sizeof(int),0666 | IPC_CREAT);
  if (shm_waiting_riders < 0)
  {
    clean_up();
    perror("Ftok failed ");
    exit(EXIT_FAILURE);
  }
  waiting_riders = (int *)shmat(shm_waiting_riders,NULL,0);
  *waiting_riders = 0;  // set it to 0 because no one is waiting

  // create process bus
	bus = fork();
  if (bus<0)  // some kind of error while creating proces bus
  {
    clean_up();
    perror("Bus process failed ");
    exit(1);
  }
	else if (bus == 0)     // child process BUS
	{
    // SINGLETON PRINTING
    sem_wait(printing);
    fprintf(fp,"%d\t\t: BUS\t\t\t: start\n", *a);
    (*a)++;
    sem_post(printing);
    // loop until there are still riders
		while(*active_riders > 0)
		{
      // SEMAPHORE STATE 1 0 0

      // SEMAPHORE STATE 0 0 0
      // lock semaphore so no rider can enter the bus stop while bus is there
			for (int i = 0; i < riders_create; i++)
      {
        sem_trywait(arrival);
      }

      // SINGLETON PRINTING
      sem_wait(printing);
      fprintf(fp,"%d\t\t: BUS\t\t\t: arrival\n", *a);
      (*a)++;
      sem_post(printing);

      int riders_boarded = 0; // contains number of riders on bus

      if (*waiting_riders > 0) // are there any riders on bus stop ? no skip this
      {

        //SINGLETON PRINTING
        sem_wait(printing);
        fprintf(fp,"%d\t\t: BUS\t\t\t: start boarding: %d\n", *a,*waiting_riders);
        (*a)++;
        sem_post(printing);
        // SEMAPHORE STATE 0 1 0
        // loop until we reach capacity or there are no riders on bus stop
  			for (int i = 0; i < bus_capacity; i++)
  			{
          sem_post(boarding); // tell waiting rider that he can enter the bus
          riders_boarded++;   // increase riders boarded on bus
          if (riders_boarded <= *waiting_riders)  // are there still any riders on station ?
          {
            sem_wait(ok); // wait for rider to finish boarding
          }
          if (riders_boarded == *waiting_riders)  // did we board all the riders ?
          {
            break;    // if yes then finish
          }
  			}

        *waiting_riders -= riders_boarded;  // decrease riders

        //SINGLETON PRINTING
        sem_wait(printing);
        fprintf(fp,"%d\t\t: BUS\t\t\t: end boarding: %d\n", *a,*waiting_riders);
        (*a)++;
        sem_post(printing);


        //SEMAPHORE STATE 0 0 0
        sem_trywait(boarding); // lock boarding if it happened to be unlocked (just to be sure)
      }

      //SINGLETON PRINTING
      sem_wait(printing);
      fprintf(fp,"%d\t\t: BUS\t\t\t: depart\n", *a);
      (*a)++;
      sem_post(printing);

      // SEMAPHORE STATE 1 0 0
      // SEMAPHORE STATE 0 0 0
      // unlock semaphore so riders can enter bus stop
      for (int i = 0; i < riders_create; i++)
      {
        sem_post(arrival);
      }

      if (bus_ride_time > 0) // is bus time 0 ? if yes then skip
      {
        // No then calculate random ride time and simulate it
  			int simulate_ride = random_max(bus_ride_time);
  			simulate_ride*= MILI_TO_MICRO;
  			usleep(simulate_ride);
      }

      //SINGLETON PRINTING
      sem_wait(printing);
      fprintf(fp,"%d\t\t: BUS\t\t\t: end\n", *a);
      (*a)++;
      sem_post(printing);

      //SEMAPHORE STATE 1 0 1
      // we finished the ride allow all the riders abourd to finish
      for (int i = 0; i < riders_boarded; i++)
      {
        // allow only the ones that boarded the bus
        sem_post(ride);
        sem_wait(ok); // wait for them to finish
      }
      //SEMAPHORE STATE 1 0 0
		}
    // SINGLETON PRINTING
    sem_wait(printing);
    fprintf(fp,"%d\t\t: BUS\t\t\t: finish\n", *a);
    (*a)++;
    sem_post(printing);
    // clean our mess after we end
    clean_up();
    exit(0);
	}
	else
	{
    // create helping proces for creating riders
		rider_creator = fork();
    if (rider_creator < 0)  // something bad happened
    {
      clean_up();
      perror("Rider creator process failed ");
      exit(1);
    }
		if (rider_creator == 0) // helping process
		{
      // create N riders given by user
			for (int i = 0; i < riders_create; i++)
			{
        if (rider_spawn_time > 0) // Is spawn time 0 ? yes then skip
        {
          // no then wait for random time, (spawntime)
          int spawn_time = random_max(rider_spawn_time);
          spawn_time*=MILI_TO_MICRO;
          usleep(spawn_time);
        }
        // create rider proces
				pid_t proc = fork();
        if (proc<0) // something bad happened
        {
          clean_up();
          perror("Rider creating failed ");
          exit(EXIT_FAILURE);
        }
				if (proc == 0) // rider process
				{
          // SINGLETON PRINTING
          sem_wait(printing);
          fprintf(fp,"%d\t\t: RID %d\t\t: start\n", *a,i+1);
          (*a)++;
          sem_post(printing);
          // wait till the bus leaves the bus stop
					sem_wait(arrival);
          (*waiting_riders)++;  // increase number of riders waiting for bus

          // SINGLETON PRINTING
          sem_wait(printing);
          fprintf(fp,"%d\t\t: RID %d\t\t: enter: %d\n", *a,i+1,*waiting_riders);
          (*a)++;
          sem_post(printing);

					sem_wait(boarding);  // wait for bus to let us board

          // SINGLETON PRINTING
          sem_wait(printing);
          fprintf(fp,"%d\t\t: RID %d\t\t: boarding\n", *a,i+1);
          (*a)++;
          sem_post(printing);
          sem_post(ok); // tell the bus we boarded successfully

          // wait for bus to finish its ride
					sem_wait(ride);

          // SINGLETON PRINTING
          sem_wait(printing);
          fprintf(fp,"%d\t\t: RID %d\t\t: finish\n", *a,i+1);
          (*a)++;
          sem_post(printing);

          (*active_riders)--; // we are finishing tell other processes
          sem_post(ok); // tell the bus we finished successfully

          //clean our mess up
          clean_up();

					exit(0);
					break;
				}
			}
      // wait till all riders finish
      while (waitpid (-1, NULL, 0)){
        if (errno == ECHILD)
        break;
      }
      // clean our mess up
      clean_up();
      exit(0);
		}
		else
		{
      // wait till all child processes finishes
			while (waitpid (-1, NULL, 0)){
				if (errno == ECHILD)
				break;
			}
      clean_up();
		}
	}
	return 0;
}
