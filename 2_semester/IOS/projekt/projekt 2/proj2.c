#include <stdio.h>          /* printf()                 */
#include <stdlib.h>         /* exit(), malloc(), free() */
#include <unistd.h>
#include <sys/types.h>      /* key_t, sem_t, pid_t      */
#include <sys/wait.h>
#include <sys/time.h>
#include <sys/shm.h>        /* shmat(), IPC_RMID        */
#include <errno.h>          /* errno, ECHILD            */
#include <semaphore.h>      /* sem_open(), sem_destroy(), sem_wait().. */
#include <fcntl.h>          /* O_CREAT, O_EXEC          */

// constant strings
#define ARRIVAL_NAME "arrival"
#define BOARDING_NAME "boarding"
#define RIDE_NAME "ride"
#define OK_NAME "ok"
#define PRINTING_NAME "printing"
#define FILE_NAME "proj2.out"
#define MILI_TO_MICRO 1000

// public variables
// will hold keys generated by ftok
key_t a_key;
key_t active_riders_key;
key_t waiting_riders_key;

// will hold shared memory value
int shm_a;
int shm_active_riders;
int shm_waiting_riders;

// shared variable
int *a = NULL;
int *active_riders = NULL;
int *waiting_riders = NULL;

// shared semaphores
sem_t *arrival = NULL;
sem_t *boarding = NULL;
sem_t *ride = NULL;
sem_t *ok = NULL;
sem_t *printing = NULL;

// contains PID of child process for main
// contains 0 for child process
pid_t bus;
pid_t rider_creator;

// file
FILE *fp;


// function declaration
int random_max(int max);
void clean_up();

// will generate random number between 0 and max
int random_max(int max)
{
  // Save time
  struct timeval t1;
  // get time of day
  gettimeofday(&t1,NULL);
  // generate seed for rand function
  srand(t1.tv_usec * t1.tv_sec);
  // minimum = 0 max will be given
  int min = 0;
  // calculate random using rand() functon with floating point numbers for more randomness
  int result = min + (max-min) * (double)rand() / (double)RAND_MAX + 0.5;
  // return result;
  return result;
}

// will clean everything if program finished succesfully or not
void clean_up()
{
  // detach memory segments
  shmdt(a);
  shmdt(active_riders);
  shmdt(waiting_riders);
  // remove shared memory identifier from the system and destroy memory segment
  shmctl(shm_a,IPC_RMID,NULL);				// IPC_RMID does not need buffer so we can use NULL
  shmctl(shm_active_riders,IPC_RMID,NULL);
  shmctl(shm_waiting_riders,IPC_RMID,NULL);

  // close semaphores
  sem_close(arrival);
  sem_close(boarding);
  sem_close(ride);
  sem_close(ok);
  sem_close(printing);

  // null semaphores
  arrival = NULL;
  boarding = NULL;
  ride = NULL;
  ok = NULL;
  printing = NULL;

  // close file
  fclose(fp);
}

int main(int argc, char **argv)
{
  // check if the arguments are correctly given
	if (argc == 5)
	{
		if (atoi(argv[1]) < 0)
		{
			fprintf(stderr,"First argument out of range.\n");
			exit(EXIT_FAILURE);
		}
		if (atoi(argv[2]) < 0)
		{
			fprintf(stderr,"Second argument out of range.\n");
			exit(EXIT_FAILURE);
		}
		if (atoi(argv[3]) > 1000|| atoi(argv[3]) < 0)
		{
			fprintf(stderr,"Third argument out of range.\n");
			exit(EXIT_FAILURE);
		}
		if (atoi(argv[4]) > 1000|| atoi(argv[4]) < 0)
		{
			fprintf(stderr,"Fourth argument out of range.\n");
			exit(EXIT_FAILURE);
		}
	}
	else
	{
		fprintf(stderr,"Not enough arguments.\n");
		exit(EXIT_FAILURE);
	}

	int riders_create = atoi(argv[1]);
	int bus_capacity = atoi(argv[2]);
	int bus_ride_time = atoi(argv[3]);
	int rider_spawn_time = atoi(argv[4]);

  fp = fopen(FILE_NAME,"w");

  // so the file buffer will be filled according to *a
  setbuf(fp, NULL);

  // opening semaphore arrival for controling entering of riders
	arrival = sem_open(ARRIVAL_NAME,O_CREAT | O_EXCL,0666,0); // initialize locked semaphore
	if (arrival == SEM_FAILED) // semapore failed to open
	{
    clean_up();
    perror("Semaphore arrival failed ");
		exit(EXIT_FAILURE);
	}
	sem_unlink(ARRIVAL_NAME);

  // opening semaphore boarding for controling when can riders board
	boarding = sem_open(BOARDING_NAME,O_CREAT | O_EXCL,0666,0); // initialize locked semaphore
	if (boarding == SEM_FAILED) // semapore failed to open
	{
    clean_up();
    perror("Semaphore boarding failed ");
		exit(EXIT_FAILURE);
	}
	sem_unlink(BOARDING_NAME);

  // opening semaphore ride for controling when can riders finish
	ride = sem_open(RIDE_NAME,O_CREAT | O_EXCL,0666,0);
	if (ride == SEM_FAILED)
	{
    clean_up();
    perror("Semaphore ride failed ");
		exit(EXIT_FAILURE);
	}
	sem_unlink(RIDE_NAME);

  // opening semaphore ok for controling bus based on rider actions
	ok = sem_open(OK_NAME,O_CREAT | O_EXCL,0666,0);
	if (ok == SEM_FAILED)
	{
    clean_up();
    perror("Semaphore ok failed ");
		exit(EXIT_FAILURE);
	}
	sem_unlink(OK_NAME);

  // controls printing into file so no 2 processes can print at the same time
  printing = sem_open(PRINTING_NAME, O_CREAT | O_EXCL,0666,1);  // initialize open
  if (printing == SEM_FAILED)
  {
    clean_up();
    perror("Semaphore printing failed ");
    exit(EXIT_FAILURE);
  }
  sem_unlink(PRINTING_NAME);

	a_key = ftok("/tmp",'a');		// convert path to key_t
	if (a_key ==  (key_t)-1)
	{
    clean_up();
		perror("Ftok failed ");
		exit(EXIT_FAILURE);
	}
	shm_a = shmget(a_key,sizeof(int),0664 | IPC_CREAT); // use the key_t to find the shared memory segment
	if (shm_a < 0)
	{
    clean_up();
		perror("Shmget failed ");
		exit(EXIT_FAILURE);
	}
	a = (int *)shmat(shm_a,NULL,0);
	*a = 1;


	active_riders_key = ftok("/tmp",'b');		// convert path to key_t
	if (active_riders_key == (key_t)-1)
	{
    clean_up();
		perror("Ftok failed ");
		exit(EXIT_FAILURE);
	}
	shm_active_riders = shmget(active_riders_key,sizeof(int),0664 | IPC_CREAT); // use the key_t to find the shared memory segment
	if (shm_active_riders < 0)
	{
    clean_up();
		perror("Shmget failed ");
		exit(1);
	}
	active_riders = (int *)shmat(shm_active_riders,NULL,0);	// attach shared memory segment
	*active_riders = riders_create;	// set shared memory to equal number of riders

  waiting_riders_key = ftok("/tmp",'c');
  if (waiting_riders_key == (key_t)-1)
  {
    clean_up();
    perror("Ftok failed ");
    exit(1);
  }
  shm_waiting_riders = shmget(waiting_riders_key,sizeof(int),0664 | IPC_CREAT);
  if (shm_waiting_riders < 0)
  {
    clean_up();
    perror("Ftok failed ");
    exit(EXIT_FAILURE);
  }
  waiting_riders = (int *)shmat(shm_waiting_riders,NULL,0);
  *waiting_riders = 0;

	bus = fork();
  if (bus<0)
  {
    clean_up();
    perror("Bus process failed ");
    exit(1);
  }
	else if (bus == 0)
	{
    sem_wait(printing);
    fprintf(fp,"%d\t\t: BUS\t\t\t: start\n", *a);
    (*a)++;
    sem_post(printing);
		while(*active_riders > 0)
		{
      // SEMAPHORE STATE 1 0 0

      // SEMAPHORE STATE 0 0 0
			for (int i = 0; i < riders_create; i++)
      {
        sem_trywait(arrival);   //2 -5 = 0
      }


      // SINGLETON PRINTING
      sem_wait(printing);
      fprintf(fp,"%d\t\t: BUS\t\t\t: arrival\n", *a);
      (*a)++;
      sem_post(printing);



      int riders_boarded = 0;

      if (*waiting_riders > 0)
      {

        //SINGLETON PRINTING
        sem_wait(printing);
        fprintf(fp,"%d\t\t: BUS\t\t\t: start boarding: %d\n", *a,*waiting_riders);
        (*a)++;
        sem_post(printing);
        // SEMAPHORE STATE 0 1 0
  			for (int i = 0; i < bus_capacity; i++) // 2
  			{
          sem_post(boarding);
          riders_boarded++;
          if (riders_boarded <= *waiting_riders)  // 1
          {
            sem_wait(ok);
          }
          if (riders_boarded == *waiting_riders)
          {
            break;
          }
  			}

        *waiting_riders -= riders_boarded;

        //SINGLETON PRINTING
        sem_wait(printing);
        fprintf(fp,"%d\t\t: BUS\t\t\t: end boarding: %d\n", *a,*waiting_riders);
        (*a)++;
        sem_post(printing);


        //SEMAPHORE STATE 0 0 0
        sem_trywait(boarding);
      }

      //SINGLETON PRINTING
      sem_wait(printing);
      fprintf(fp,"%d\t\t: BUS\t\t\t: depart\n", *a);
      (*a)++;
      sem_post(printing);

      // SEMAPHORE STATE 1 0 0
      // SEMAPHORE STATE 0 0 0
      for (int i = 0; i < riders_create; i++)
      {
        sem_post(arrival);
      }

      if (bus_ride_time > 0)
      {
  			int simulate_ride = random_max(bus_ride_time);
  			simulate_ride*= MILI_TO_MICRO;
  			usleep(simulate_ride);
        //SINGLETON PRINTING
      }
      sem_wait(printing);
      fprintf(fp,"%d\t\t: BUS\t\t\t: end\n", *a);
      (*a)++;
      sem_post(printing);

      //SEMAPHORE STATE 1 0 1
      for (int i = 0; i < riders_boarded; i++)
      {
        // allow only the ones that boarded the bus
        sem_post(ride);
        sem_wait(ok);
      }
      //SEMAPHORE STATE 1 0 0
		}
    sem_wait(printing);
    fprintf(fp,"%d\t\t: BUS\t\t\t: finish\n", *a);
    (*a)++;
    sem_post(printing);
    clean_up();
    exit(0);
	}
	else
	{
		rider_creator = fork();
    if (rider_creator < 0)
    {
      clean_up();
      perror("Rider creator process failed ");
      exit(1);
    }
		if (rider_creator == 0)
		{
			for (int i = 0; i < riders_create; i++)
			{
        if (rider_spawn_time > 0)
        {
          int spawn_time = random_max(rider_spawn_time);
          spawn_time*=MILI_TO_MICRO;
          usleep(spawn_time);
        }

				pid_t proc = fork();
        if (proc<0)
        {
          clean_up();
          perror("Rider creating failed ");
          exit(EXIT_FAILURE);
        }
				if (proc == 0)
				{
          sem_wait(printing);
          fprintf(fp,"%d\t\t: RID %d\t\t: start\n", *a,i+1);
          (*a)++;
          sem_post(printing);

					sem_wait(arrival);
          (*waiting_riders)++;

          sem_wait(printing);
          fprintf(fp,"%d\t\t: RID %d\t\t: enter: %d\n", *a,i+1,*waiting_riders);
          (*a)++;
          sem_post(printing);


					sem_wait(boarding);  // wait for bus to let us board
          sem_wait(printing);
          fprintf(fp,"%d\t\t: RID %d\t\t: boarding\n", *a,i+1);
          (*a)++;
          sem_post(printing);
          sem_post(ok); // tell the bus we boarded successfully


					sem_wait(ride);

          sem_wait(printing);
          fprintf(fp,"%d\t\t: RID %d\t\t: finish\n", *a,i+1);
          (*a)++;
          sem_post(printing);
					(*active_riders)--;
          sem_post(ok); // tell the bus we finished successfully

          clean_up();

					exit(0);
					break;
				}
			}
      clean_up();
      exit(0);
		}
		else
		{
			while (waitpid (-1, NULL, 0)){
				if (errno == ECHILD)
				break;
			}
      clean_up();
		}
	}
	return 0;
}
